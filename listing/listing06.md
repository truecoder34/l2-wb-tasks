Что выведет программа? Объяснить вывод программы. Рассказать про внутреннее устройство слайсов и что происходит при передачи их в качестве аргументов функции.

```go
package main

import (
	"fmt"
)

func main() {
	var s = []string{"1", "2", "3"}
	modifySlice(s)
	fmt.Println(s)
}

func modifySlice(i []string) {
	i[0] = "3"
	i = append(i, "4")
	i[1] = "5"
	i = append(i, "6")
}
```

Ответ:
```
[3 2 3]
```

- Слайс это структура данных, состоящая из указателя на массив, длины и емкости. Он описывает сегмент массива и предоставляет удобные инструменты для работы с этим сегментом.

- Ссылка указывает не просто на массив, а на первый элемент массива, используемого в слайсе.

- Длина слайса позволяет определить количество элементов в слайсе.

- Емкость показывает максимальное количество элементов, которое поместится в базовый массив начиная с первого элемента слайса до конца этого массива.

- Если при добавлении элементов в слайс происходит превышение емкости, то создается новый массив большей длины, куда копируются все имеющиеся значения.

- В зависимости от исходных условий последствия от передачи слайса в функцию могут быть различными.

- Если в результате операций внутри функции не происходило переполнение базового массива, но производились операции по изменению значений по индексам - тогда изменения отразятся на исходном слайсе, так как он указывает на тот же самый массив.

- Если в функцию была передана лишь часть слайса и внутри функции к этой части добавлялись элементы методом append, но емкость базового слайса не была превышена, то элементы, следующие за конечным элементом переданного слайса будут перезаписаны в исходном слайсе.

- Если в ходе операций в функции был переполнен базовый массив, то последующие операции с локальным слайсом не будут влиять на слайс из внешней области, так как будет создан новый массив, не связанный с исходным.

- В примере выше первый элемент исходного слайса был перезаписан, так как новый базовый массив не был создан. Операция append привела к созданию нового базового массива для слайса ввиду превышения емкости, и последующие измененения не отразились во внешней области.

- Увеличение емкости при вызове функции append определяется исходя из следующего соотношения:

starting cap    growth factor
256             2.0
512             1.63
1024            1.44
2048            1.35
4096            1.30